# 순위

## 풀이방법

### 위상정렬 - 실패
일반적인 위상정렬의 방식의 경우, indigree가 0인 노드들부터 Queue에 삽입하는 방식으로 순차적으로 처리하는 방식이다.
이 방식을 응용하여, 본인이 지거나 이긴 경우들에 대해서 set자료구조로 저장하고 있는 배열의 크기의 합이 n -1과 같은 경우 진입차수가 0인 것으로 간주했다.
문제에 제시된 테스트 케이스는 통과했지만, 아래의 케이스에서는 성공적으로 동작하지 않았다.
```
Input
7, [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5], [5,6], [6,7]])
Answer 
4
```
이 케이스에서는 진입차수가 0을 만족하는 노드가 시작 당시에는 존재하지 않는다. 즉, 그래프 탐색을 통해 그래프를 채워야지만 진입차수가 0인 노드들을 발견할 수 있기에, [wa.cpp](./wa.cpp)의 코드가 정상적으로 동작하지 않았다.

### BFS - 성공
위 실패 과정을 통해 다음과 같이 방식을 정립했다.
1. 순위를 알 수 있는 경우는 모든 노드들과의 결과를 알고 있을 경우에만 해당한다.
2. 순위를 알기 전에, 그래프 탐색을 통해서 모든 노드들끼리 결과를 공유해야 한다.

2번 과정을 구현하기 위해 BFS를 활용했다. 문제를 다 풀고 나서 드는 생각이지만, DFS가 더 구현에 용이했을 것이라고 판단한다.
BFS를 구현하면서 생각했던 고민은 "재방문의 경우가 없을 것인가?"에 대한 부분이었다. 즉, 방문처리를 한 이후에 해당 노드가 갱신되는 경우가 발생할 수 있는가에 대한 확인을 진행했다.
명확한 테스트 케이스는 찾지 못했지만, 가능할 수 있다는 생각이 들어 큐 삽입 기준을 다시 정립했다.
새로운 큐 삽입 기준은 그래프 탐색 과정에서 해당 노드에게 새로운 삽입이 일어났는가였습니다.
이 기준을 통해 무한 루프가 발생하는 경우를 방지했습니다.

## 결과
정확성: 100.0
합계: 100.0 / 100.0