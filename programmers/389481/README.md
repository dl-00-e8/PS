# 봉인된 주문

## 풀이 방법

### 정답 풀이 - Implementation

처음 문제를 보았을 때, 주어진 요구사항을 봤을 때 구현 자체가 어렵지는 않다고 판단했다. 다만, 문제 조건에서 n은 최대 10^15까지 가능하다는 게 핵심이었다.
10^15는 O(N)으로 전체 순회를 하면서, ban 리스트들을 확인하는 방식으로는 구현이 달성할 수 없는 조건이기에 더 최적화된 방법을 찾아야 한다는 의미가 되었다.
그렇기 때문에, 첫 번째로는 금지된 문자열을 제거하면서 얼마나 더 뒤로 n을 옮겨주어야 하는지를 계산하는 과정부터 접근했다.

먼저, 문제 조건 상 bans가 정렬되어 있지 않을 수 있다는 점에 주목했다.
문제에서 n은 길이가 작은 순/사전에서 앞서는 순으로 정렬된 숫자들에서 index를 의미한다고 했는데, bans를 통해서 제거해주기 위해서는 동일한 방식으로 정렬해서 비교하는 것이 필요하기 때문이다.

bans를 정렬한 이후, 순차적으로 비교하기 위해서 queue 자료구조를 활용해서 금지된 리스트들을 담았다.

이후, 자릿수를 증가시키면서 현재 bans로 인해 변하게 되는 index를 확인하는 과정을 진행했다. bans에서 몇 개를 제거시킬 수 있는지 확인하기 위해 queue의 front를 확인하고 제거하는 작업을 진행했다.

제거할 수 있는지 확인하기 위해서는 두 방법 중 하나의 방법이 구현되어야 했다.
현재의 string이 숫자로 변환하면 몇 번째 index에 해당하는지를 변환하거나, 현재의 index가 변환하면 어떤 string에 해당하는지이다.
나는 후자의 방법을 구현하기 위해 get_string 메소드를 별도로 만들었다.

get_string 메소드는 n을 26진법처럼 생각하고, 계속 나누면서 자릿수별로 어떤 알파벳을 가지게 되는지를 계산한다. 나머지가 0이라면 z로 간주하고, 나머지가 0이 아닌 경우에는 'a'에서 그 나머지를 더하는 방식으로 구현했다.

## 결과
정확성 100.0/100.0